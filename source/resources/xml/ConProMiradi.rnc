# $LastChangedBy: nimbooce $ 
# $LastChangedDate: 2008-07-28 16:29:50 -0400 (Mon, 28 Jul 2008) $
# $LastChangedRevision: 30 $ 
#

namespace cp = "http://services.tnc.org/schema/conservation-project/0.3"

#
start = conservation_project.element
#
conservation_project.element =
    [ documentation [ "XML Schema definition to represent a Conservation Project." ] ]
    element cp:conservation_project {
        document_exchange.element
        & project_summary.element
        & targets.element
        & threats.element
        & objectives.element
        & strategies.element
        & indicators.element
    }
#
document_exchange.element =
    [
        documentation [
            "The data exchange needs to provide a way to let another application \x{a}" ~
            "know if the export was successful or not. If it wasn't, an error message \x{a}" ~
            "should be provided. The 'status' and 'error_msg' attributes take care of this \x{a}" ~
            "and are noted in the 'cp:conservation-project' root element."
        ]
    ]
    element cp:document_exchange {
        attribute status { vocabulary_doc_exchange_status }
        & element cp:error_msg { text }*
    }?
#
project_summary.element =
    element cp:project_summary {
        attribute share_outside_organization { xsd:boolean }
        & project_id.element
        & parent_project_id.element
        & element cp:name {
              xsd:string { minLength = "1" }
          }
        & element cp:start_date { vocabulary_date }?
        & area_size.element?
        & geospatial_location.element?
        & element cp:description_comment { text }?
        & element cp:goal_comment { text }?
        & element cp:planning_team_comment { text }?
        & element cp:lessons_learned { text }?
        & element cp:stressless_threat_rank { vocabulary_ranking_vhhml }?
        & element cp:project_threat_rank { vocabulary_ranking_vhhml }?
        & element cp:project_viability_rank { vocabulary_rating_vggfp }?
        & team.element
        & ecoregions.element
        & countries.element
        & ous.element
        & element cp:exporter_name { xsd:NMTOKEN }
        & element cp:exporter_version { xsd:NMTOKEN }
        & element cp:export_date { vocabulary_date }
    }
#
project_id.element =
    element cp:project_id {
        # Context, for now, is 'ConPro.' Revisit as required.
        attribute context { xsd:NMTOKEN }
        & xsd:NMTOKEN
    }*
#
parent_project_id.element =
    element cp:parent_project_id {
        # Context, for now, is 'ConPro.' Revisit as required.
        attribute context { xsd:NMTOKEN }
        & xsd:NMTOKEN
    }*
#
area_size.element =
    element cp:area_size {
        attribute unit { vocabulary_area_unit }
        & xsd:nonNegativeInteger
    }
#
geospatial_location.element =
    element cp:geospatial_location {
        attribute type { vocabulary_geospatial_type }
        & element cp:latitude { xsd:decimal }?
        & element cp:longitude { xsd:decimal }?
    }
#
team.element =
    element cp:team {
        element cp:person {
            element cp:role { vocabulary_team }+
            & element cp:givenname { xsd:string }?
            & element cp:surname { xsd:string }?
            & element cp:email { xsd:string }?
            & element cp:phone { xsd:string }?
            & element cp:organization { xsd:string }?
        }*
    }
#
ecoregions.element =
    element cp:ecoregions {
        element cp:ecoregion_code { vocabulary_ecoregion }*
    }
#
countries.element =
    element cp:countries {
        element cp:country_code { vocabulary_country }*
    }
#
ous.element =
    element cp:ous {
        element cp:ou_code { vocabulary_ou }*
    }
#
targets.element =
    element cp:targets {
        element cp:target {
            attribute sequence { vocabulary_sequence }?
            & attribute id { vocabulary_id }
            & element cp:name { text }
            & element cp:description { text }?
            & element cp:description_comment { text }?
            & element cp:target_viability_rank {
                  attribute target_viability_mode { vocabulary_viability_mode }
                  & vocabulary_ranking_vggfp
              }?
            & element cp:target_viability_comment { text }?
            & habitat_taxonomy_codes.element
            & nested_targets.element
            & strategy_threat_target_associations.element
            & stresses.element
            & threat_target_associations.element
            & key_attributes.element
        }*
    }
#
habitat_taxonomy_codes.element =
    element cp:habitat_taxonomy_codes {
        element cp:habitat_taxonomy_code { iucn_habitat_taxonomy }*
    }
#
nested_targets.element =
    element cp:nested_targets {
        element cp:nested_target {
            attribute sequence { vocabulary_sequence }
            & element cp:name { text }
            & element cp:comment { text }?
        }*
    }
#
strategy_threat_target_associations.element =
    element cp:strategy_threat_target_associations {
        element cp:strategy_threat_target_association {
            element cp:strategy_id { vocabulary_id }
            & element cp:threat_id { vocabulary_id }
        }*
    }
#
stresses.element =
    element cp:stresses {
        element cp:stress {
            attribute sequence { vocabulary_sequence }
            & element cp:name { text }
            & element cp:stress_severity { vocabulary_ranking_vhhml }?
            & element cp:stress_scope { vocabulary_ranking_vhhml }?
            & element cp:stress_to_target_rank { vocabulary_ranking_vhhml }?
            & threat_stress_ratings.element
        }*
    }
#
threat_stress_ratings.element =
    element cp:threat_stress_ratings {
        element cp:threat_stress_rating {
            element cp:threat_id { vocabulary_id }
            & element cp:contrib_rank { vocabulary_ranking_vhhml }?
            & element cp:irreversible_rank { vocabulary_ranking_vhhml }?
            & element cp:stress_threat_to_target_rank { vocabulary_ranking_vhhml }?
        }*
    }
#
threat_target_associations.element =
    element cp:threat_target_associations {
        element cp:threat_target_association {
            element cp:threat_id { vocabulary_id }
            & element cp:threat_to_target_rank { vocabulary_ranking_vhhml }?
            & element cp:threat_severity { vocabulary_ranking_vhhml }?
            & element cp:threat_scope { vocabulary_ranking_vhhml }?
            & element cp:threat_irreversibility { vocabulary_ranking_vhhml }?
            & element cp:threat_target_comment { text }?
        }*
    }
#
key_attributes.element =
    element cp:key_attributes {
        element cp:key_attribute {
            element cp:name { text }
            & element cp:category { vocabulary_key_ecological_attribute_category }?
            & viability.element
        }*
    }
#
viability.element =
    element cp:viability_assessments {
        element cp:viability_assessment {
            element cp:indicator_id { vocabulary_id }
            & element cp:indicator_description_poor { text }?
            & element cp:indicator_description_fair { text }?
            & element cp:indicator_description_good { text }?
            & element cp:indicator_description_very_good { text }?
            & element cp:current_indicator_status_viability { text }?
            & element cp:current_viability_rating { vocabulary_rating_vggfp }?
            & element cp:desired_viability_rating { vocabulary_rating_vggfp }?
            & element cp:current_rating_date { vocabulary_date }?
            & element cp:desired_rating_date { vocabulary_date }?
            & element cp:confidence_current_rating { text }?
            & element cp:kea_and_indicator_comment { text }?
            & element cp:indicator_rating_comment { text }?
            & element cp:current_rating_comment { text }?
            & element cp:desired_rating_comment { text }?
            & element cp:viability_record_comment { text }?
        }*
    }
#
threats.element =
    element cp:threats {
        element cp:threat {
            attribute id { vocabulary_id }
            & element cp:name { text }
            & element cp:threat_taxonomy_code { iucn_threat_taxonomy }?
            & element cp:threat_to_project_rank { vocabulary_ranking_vhhml }?
        }*
    }
#
objectives.element =
    element cp:objectives {
        element cp:objective {
            attribute id { vocabulary_id }
            & element cp:indicators {
                  element cp:indicator_id { vocabulary_id }*
              }
            & element cp:name { text }
            & element cp:comment { text }?
        }*
    }
#
strategies.element =
    element cp:strategies {
        element cp:strategy {
            attribute id { vocabulary_id }
            & element cp:objectives {
                  element cp:objective_id { vocabulary_id }*
              }
            & element cp:name { text }
            & element cp:taxonomy_code { iucn_strategy_taxonomy }?
            & element cp:selected { xsd:boolean }?
            & element cp:comment { text }?
            & element cp:legacy_strategy_ranking { text }?
            & element cp:status { vocabulary_status }?
            & activities.element?
        }*
    }
#
activities.element =
    element cp:activities {
        element cp:activity {
            element cp:name { text }
            & element cp:start_date { vocabulary_date }?
            & element cp:end_date { vocabulary_date }?
            & element cp:status { vocabulary_status }?
        }*
    }
#
indicators.element =
    element cp:indicators {
        element cp:indicator {
            attribute id { vocabulary_id }
            & element cp:name { text }
            & element cp:methods { text }?
            & element cp:priority { vocabulary_priority_vhhml }?
            & element cp:status { vocabulary_status }?
            & element cp:who_monitors { text }?
            & element cp:annual_cost { xsd:decimal }?
            & element cp:comment { text }?
        }*
    }
#
vocabulary_date = xsd:NMTOKEN { pattern = "[0-9]{4}-[0-9]{2}-[0-9]{2}" }
vocabulary_area_unit = "hectares"
vocabulary_country = xsd:NMTOKEN { pattern = "[A-Z]{3}" }
vocabulary_doc_exchange_status = "success" | "warning" | "fail"
vocabulary_ecoregion = xsd:NMTOKEN { pattern = "[123][\d]{4}" }
vocabulary_geospatial_type = "point"
vocabulary_id = xsd:nonNegativeInteger
vocabulary_key_ecological_attribute_category = "Condition" | "Landscape Context" | "Size"
vocabulary_ou = xsd:NMTOKEN { pattern = "\S{5}" }
vocabulary_priority_vhhml = "Very High" | "High" | "Medium" | "Low"
vocabulary_rating_vggfp = "Very Good" | "Good" | "Fair" | "Poor"
vocabulary_ranking_vggfp = "Very Good" | "Good" | "Fair" | "Poor"
vocabulary_ranking_vhhml = "Very High" | "High" | "Medium" | "Low"
vocabulary_sequence = xsd:nonNegativeInteger
vocabulary_status = "Planned" | "Major Issues" | "Minor Issues" | "On Track" | "Completed" | "Abandoned"
vocabulary_team = "Owner" | "Team Leader" | "Team Member"
vocabulary_viability_mode = "kea" | "simple"
#
[
    documentation [
        "International Union for Conservation of Nature (IUCN) threat, habitat and \x{a}" ~
        "strategy taxonomy formats:"
    ]
]
iucn_threat_taxonomy = xsd:NMTOKEN { pattern = "[T][0-9]{2,3}\.[0-9]{2,3}" }
iucn_habitat_taxonomy = xsd:NMTOKEN { pattern = "[H][0-9]{2,3}\.[0-9]{2,3}" }
iucn_strategy_taxonomy = xsd:NMTOKEN { pattern = "[A][0-9]{2,3}\.[0-9]{2,3}" }
# 
# 
# Notes:
#    1) ConPro will produce the following for direct import to Miradi's Indication Comment field: 
#         This field is made up of the following five fields with field names followed by ":" and field contents:
#         "Freq & Timing," "Location," "Funding," "Plan Complete," "Last Updated"
# 
# 
# Datatyping reference
# xsd:boolean -  Its value space is true and false. Its lexical space accepts true, false, 1 and 0
# vocabulary_date -     
#                Its lexical space is the ISO 8601 extended format [-]CCYY-MM-DD[Z|(+|-)hh:mm] with 
#                an optional time zone. 
# xsd:decimal -  The set of all decimal numbers with arbitrary lengths. Its lexical space allows any
#                number of insignificant leading and, after the decimal point, trailing zeros. A period
#                is the only acceptable decimal seperator. No thousands seperators allowed.
# xsd:integer -  Integer is derived from decimal by fixing the value of fractionDigits to be 0 and disallowing 
#                the trailing decimal point. This results in the standard mathematical concept of the integer 
#                numbers. The value space of integer is the infinite set {...,-2,-1,0,1,2,...}. 
# xsd:nonNegativeInteger - 
#                nonNegativeInteger is derived from integer by setting the value of
#                minInclusive to be 0. This results in the standard mathematical concept of the 
#                non-negative integers. The value space of nonNegativeInteger is the infinite 
#                set {0,1,2,...}.
# xsd:positiveInteger - 
#                positiveInteger is derived from nonNegativeInteger by setting the value of
#                minInclusive to be 1. This results in the standard mathematical concept of the 
#                positive integer numbers. The value space of positiveInteger is the infinite 
#                set {1,2,...}. 
# xsd:string -   The lexical and value spaces are teh set of all possible strings composed of any charachter 
#                allowed in a XML 1.0 document without any treatment done on whitespace. That is the only 
#                datatype that leaves all the whitespace. When whitespace isn't significant, xsd:token is
#                preferred.
# xsd:token -    The value space of token is the set of strings that do not contain the carriage return (#xD), 
#                line feed (#xA) nor tab (#x9) characters, that have no leading or trailing spaces (#x20) and 
#                that have no internal sequences of two or more spaces. The lexical space of token is the set 
#                of strings that do not contain the carriage return (#xD), line feed (#xA) nor tab (#x9) 
#                characters, that have no leading or trailing spaces (#x20) and that have no internal sequences 
#                of two or more spaces.
# xsd:NMTOKEN -  The lexical and value spaces are the set of XML 1.0 name tokens, tokens composed of characters
#                digits, period, colons, hyphens and the characters defined by Unicode, such as "combining"
#                or "extender." Invalid values include 'brought classical music' (spaces are forbidden) and
#                'bold,brash' (commas are forbidden).
# 
#  * - 0 or more
#  + - 1 or more
#  ? - Optional

# $LastChangedBy: ecoffman $ 
# $LastChangedDate: 2008-04-02 10:55:24 -0400 (Wed, 02 Apr 2008) $
# $LastChangedRevision: 2104 $ 

# 
# Datatyping reference
# xsd:boolean -  Its value space is true and false. Its lexical space accepts true, false, 1 and 0
# xsd:date -     Its lexical space is the ISO 8601 extended format [-]CCYY-MM-DD[Z|(+|-)hh:mm] with 
#                an optional time zone. 
# xsd:decimal -  The set of all decimal numbers with arbitrary lengths. Its lexical space allows any
#                number of insignificant leading and, after the decimal point, trailing zeros. A period
#                is the only acceptable decimal seperator. No thousands seperators allowed.
# xsd:integer -  Integer is derived from decimal by fixing the value of fractionDigits to be 0 and disallowing 
#                the trailing decimal point. This results in the standard mathematical concept of the integer 
#                numbers. The value space of integer is the infinite set {...,-2,-1,0,1,2,...}. 
# xsd:nonNegativeInteger - 
#                nonNegativeInteger is derived from integer by setting the value of
#                minInclusive to be 0. This results in the standard mathematical concept of the 
#                non-negative integers. The value space of nonNegativeInteger is the infinite 
#                set {0,1,2,...}.
# xsd:positiveInteger - 
#                positiveInteger is derived from nonNegativeInteger by setting the value of
#                minInclusive to be 1. This results in the standard mathematical concept of the 
#                positive integer numbers. The value space of positiveInteger is the infinite 
#                set {1,2,...}. 
# xsd:string -   The lexical and value spaces are teh set of all possible strings composed of any charachter 
#                allowed in a XML 1.0 document without any treatment done on whitespace. That is the only 
#                datatype that leaves all the whitespace. When whitespace isn't significant, xsd:token is
#                preferred.
# xsd:token -    The value space of token is the set of strings that do not contain the carriage return (#xD), 
#                line feed (#xA) nor tab (#x9) characters, that have no leading or trailing spaces (#x20) and 
#                that have no internal sequences of two or more spaces. The lexical space of token is the set 
#                of strings that do not contain the carriage return (#xD), line feed (#xA) nor tab (#x9) 
#                characters, that have no leading or trailing spaces (#x20) and that have no internal sequences 
#                of two or more spaces.
# xsd:NMTOKEN -  The lexical and value spaces are the set of XML 1.0 name tokens, tokens composed of characters
#                digits, period, colons, hyphens and the characters defined by Unicode, such as "combining"
#                or "extender." Invalid values include 'brought classical music' (spaces are forbidden) and
#                'bold,brash' (commas are forbidden).

# Notes:
#    ? - Optional
#    * - 0 or more
#    + - 1 or more
# 
#    & - interleave
#

# --------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------

default namespace = "http://services.tnc.org/schema/conservation-project/"
namespace cp = "http://services.tnc.org/schema/conservation-project/0.1"

# 
# 
#
start = conservation_project.element
# 
#
conservation_project.element =
    [ documentation [ "XML Schema definition to represent a Conservation Project." ] ]
    element cp:conservation_project {
        document_exchange.element
        & project_summary.element
        & targets.element
        & key_attributes.element
        & viability.element
        & threats.element
        & objectives.element
        & strategies.element
        & indicators.element
    }
# 
# 
#
document_exchange.element =
    [
        documentation [
            "The data exchange needs to provide a way to let another application \x{a}" ~
            "know if the export was successful or not. If it wasn't, an error message \x{a}" ~
            "should be provided. The 'status' and 'error_msg' attributes take care of this \x{a}" ~
            "and are noted in the 'cp:conservation-project' root element. \x{a}" ~
            " \x{a}" ~
            "These attributes are useful to let Miradi know there was an error producing the \x{a}" ~
            "XML in ConPro when the data was obtained by some more automatic way (Web Service). \x{a}" ~
            "An example of some automatic way is when a user in Miradi wants to import their \x{a}" ~
            "data from ConPro via a direct import method. Miradi might provide a function where \x{a}" ~
            "the user could enter the ConPro ID and Miradi fetches the data without the user \x{a}" ~
            "having to do the actual downloading from ConPro and uploading to Miradi."
        ]
    ]
    element cp:document_exchange {
        attribute status { vocabulary_doc_exchange_status }
        & element cp:error_msg { text }*
    }?
# 
# 
#
project_summary.element =
    element cp:project_summary {
        attribute share_outside_organization { xsd:boolean }
        & element project_id {
              [ documentation [ "Context, for now, is 'ConPro.' Revisit as required." ] ]
              attribute context { xsd:NMTOKEN }
              & xsd:NMTOKEN
          }*
        & element cp:parent_project_id {
              [ documentation [ "Context, for now, is 'ConPro.' Revisit as required." ] ]
              attribute context { xsd:NMTOKEN }
              & xsd:NMTOKEN
          }*
        & [ documentation [ "ConPro will normalize this string to fit xsd:token " ] ]
          element cp:name { xsd:string }
        & element cp:start_date { xsd:date }?
        & area_size.element?
        & location.element?
        & element cp:description_comment { text }?
        & element cp:goal_comment { text }?
        & element cp:planning_team_comment { text }?
        & element cp:lessons_learned { text }?
        & element cp:stressless_threat_rank { vocabulary_ranking_vhhml }?
        & element cp:project_threat_rank { vocabulary_ranking_vhhml }?
        & element cp:project_viability_rank { vocabulary_ranking_vhhml }?
        & team.element
        & element cp:ecoregions {
              element cp:ecoregion_code { vocabulary_ecoregions }*
          }
        & element cp:countries {
              element cp:country_code { vocabulary_countries }*
          }
        & element cp:ous {
              element cp:ou_code { vocabulary_ous }*
          }
        & element cp:exporter_name { xsd:NMTOKEN }
        & element cp:exporter_version { xsd:NMTOKEN }
        & element cp:data_export_date { xsd:date }
    }
# 
# 
#
area_size.element =
    element cp:area_size {
        attribute unit { vocabulary_area_unit }
        & xsd:nonNegativeInteger
    }
# 
# 
#
location.element =
    element cp:geospatial_location {
        attribute type { vocabulary_geospatial_type }
        & element cp:latitude { xsd:decimal }?
        & element cp:longitude { xsd:decimal }?
    }
# 
# 
#
team.element =
    element cp:team {
        element cp:person {
            element cp:role { vocabulary_team }+
            & element cp:givenname { xsd:string }?
            & element cp:surname { xsd:string }?
            & element cp:email { xsd:string }?
            & element cp:phone { xsd:string }?
            & element cp:organization { xsd:string }?
        }*
    }
# 
# 
#
targets.element =
    element cp:targets {
        element cp:target {
            attribute sequence { xsd:positiveInteger }?
            & attribute id { vocabulary_id }
            & [ documentation [ "ConPro will normalize this string to fit xsd:token " ] ]
              element cp:name { text }
            & element cp:description { text }?
            & element cp:description_comment { text }?
            & element cp:target_viability_comment { text }?
            & element cp:target_viability_rank { vocabulary_ranking_vhhml }?
            & element cp:habitat_taxonomy_codes {
                  element cp:habitat_taxonomy_code { iucn_habitat_taxonomy }*
              }
            & element cp:target_stresses { target_stress.element* }
            & element cp:stresses_threats { stresses_threat.element* }
            & element cp:nested_targets { nested_target.element* }
            & element cp:threat_target_associations { threat_target_association.element* }
            & element cp:strategy_threat_target_associations {
                  strategy_threat_target_association.element*
              }
        }*
    }
# 
# 
#
target_stress.element =
    element cp:target_stress {
        attribute sequence { xsd:nonNegativeInteger }
        & [ documentation [ "ConPro will normalize this string to fit xsd:token " ] ]
          element cp:name { text }
        & element cp:stress_severity { vocabulary_ranking_vhhml }?
        & element cp:stress_scope { vocabulary_ranking_vhhml }?
        & element cp:stress_to_target_rank { vocabulary_ranking_vhhml }?
    }
# 
# 
#
stresses_threat.element =
    element cp:stresses_threat {
        element cp:contrib_rank { vocabulary_ranking_vhhml }?
        & element cp:irreversible_rank { vocabulary_ranking_vhhml }?
        & element cp:stress_threat_to_target_rank { vocabulary_ranking_vhhml }?
    }
# 
# 
#
nested_target.element =
    element cp:nested_target {
        attribute sequence { xsd:nonNegativeInteger }
        & [ documentation [ "ConPro will normalize this string to fit xsd:token " ] ]
          element cp:name { text }
        & element cp:comment { text }?
    }
# 
# 
#
threat_target_association.element =
    element cp:threat_target_association {
        element cp:threat_id { xsd:nonNegativeInteger }
        & element cp:threat_to_target_rank { vocabulary_ranking_vhhml }?
        & element cp:threat_severity { vocabulary_ranking_vhhml }?
        & element cp:threat_scope { vocabulary_ranking_vhhml }?
        & element cp:threat_irreversibility { vocabulary_ranking_vhhml }?
        & element cp:threat_target_comment { text }?
    }
# 
# 
#
strategy_threat_target_association.element =
    element cp:strategy_threat_association {
        element cp:strategy_id { xsd:nonNegativeInteger }
        & element cp:threat_id { xsd:nonNegativeInteger }
    }
# 
# 
#
key_attributes.element =
    element cp:key_attributes {
        element cp:key_attribute {
            attribute id { vocabulary_id }
            & [ documentation [ "ConPro will normalize this string to fit xsd:token " ] ]
              element cp:name { text }
            & element cp:category { vocabulary_key_ecological_attribute_category }
        }*
    }
# 
# 
#
viability.element =
    element cp:viability {
        element cp:viability_assessment {
            element cp:target_id { xsd:nonNegativeInteger }
            & element cp:indicator_id { xsd:nonNegativeInteger }
            & element cp:kea_id { xsd:nonNegativeInteger }
            & element cp:indicator_description_poor { text }?
            & element cp:indicator_description_fair { text }?
            & element cp:indicator_description_good { text }?
            & element cp:indicator_description_very_good { text }?
            & element cp:current_indicator_status_viability { text }?
            & element cp:current_viability_rating { text }?
            & element cp:desired_viability_rating { text }?
            & element cp:current_rating_date { xsd:date }?
            & element cp:desired_rating_date { xsd:date }?
            & element cp:confidence_current_rating { text }?
            & element cp:kea_and_indicator_comment { text }?
            & element cp:indicator_rating_comment { text }?
            & element cp:current_rating_comment { text }?
            & element cp:desired_rating_comment { text }?
            & element cp:viability_record_comment { text }?
        }*
    }
# 
# 
#
threats.element =
    element cp:threats {
        element cp:threat {
            attribute id { vocabulary_id }
            & [ documentation [ "ConPro will normalize this string to fit xsd:token " ] ]
              element cp:name { text }
            & element cp:threat_taxonomy_code { iucn_threat_taxonomy }?
            & element cp:threat_to_project_rank { vocabulary_ranking_vhhml }?
        }*
    }
# 
# 
#
objectives.element =
    element cp:objectives {
        element cp:objective {
            attribute id { vocabulary_id }
            & element cp:indicators {
                  element cp:indicator_id { xsd:nonNegativeInteger }*
              }
            & [ documentation [ "ConPro will normalize this string to fit xsd:token " ] ]
              element cp:name { text }
            & element cp:comment { text }?
        }*
    }
# 
# 
#
strategies.element =
    element cp:strategies {
        element cp:strategy {
            attribute id { vocabulary_id }
            & element cp:objectives {
                  element cp:objective_id { xsd:nonNegativeInteger }*
              }
            & [ documentation [ "ConPro will normalize this string to fit xsd:token " ] ]
              element cp:name { text }
            & element cp:taxonomy_code { iucn_strategy_taxonomy }?
            & element cp:leverage { vocabulary_ranking_vhhml }?
            & element cp:feasibility { vocabulary_ranking_vhhml }?
            & element cp:overall_rank { vocabulary_ranking_vhhml }?
            & element cp:selected { xsd:boolean }?
            & element cp:comment { text }?
            & activities.element?
        }*
    }
# 
# 
#
activities.element =
    element cp:activities {
        element cp:activity {
            [ documentation [ "ConPro will normalize this string to fit xsd:token " ] ]
            element cp:name { text }
            & element cp:start_date { xsd:date }?
            & element cp:end_date { xsd:date }?
        }*
    }
# 
# 
#
indicators.element =
    element cp:indicators {
        element cp:indicator {
            attribute id { vocabulary_id }
            & [ documentation [ "ConPro will normalize this string to fit xsd:token " ] ]
              element cp:name { text }
            & element cp:methods { xsd:token }?
            & element cp:priority { vocabulary_priority_vhhml }?
        }*
    }
# 
# 
#
vocabulary_area_unit = "hectares"
vocabulary_countries = xsd:NMTOKEN { pattern = "[A-Z]{3}" }
vocabulary_doc_exchange_status = "success" | "warning" | "fail"
vocabulary_ecoregions = xsd:NMTOKEN { pattern = "[123][\d]{4}" }
vocabulary_geospatial_type = "point"
vocabulary_id = xsd:double
vocabulary_key_ecological_attribute_category = "Condition" | "Landscape Context" | "Size"
vocabulary_ous = xsd:NMTOKEN { pattern = "\S{5}" }
vocabulary_priority_vhhml = "Very High" | "High" | "Medium" | "Low"
vocabulary_rating_vggfp = "Very Good" | "Good" | "Fair" | "Poor"
vocabulary_ranking_vhhml = "Very High" | "High" | "Medium" | "Low"
vocabulary_status = "Planned" | "Off Track" | "On Track" | "Completed"
vocabulary_team = "Owner" | "Team Leader" | "Team Member"
# 
#
[
    documentation [
        "International Union for Conservation of Nature (IUCN) threat, habitat and \x{a}" ~
        "strategy taxonomy formats:"
    ]
]
iucn_threat_taxonomy = xsd:NMTOKEN { pattern = "[T][0-9]{2,3}\.[0-9]{2,3}" }
iucn_habitat_taxonomy = xsd:NMTOKEN { pattern = "[H][0-9]{2,3}\.[0-9]{2,3}" }
iucn_strategy_taxonomy = xsd:NMTOKEN { pattern = "[A][0-9]{2,3}\.[0-9]{2,3}" }
